import { e as error } from "./index.js";
import { w as window, g as get_store_value } from "./window.js";
import { p as persisted } from "./index3.js";
import StellarSdk, { TransactionBuilder, Networks, Utils } from "stellar-sdk";
import "lodash/debounce.js";
import BigNumber from "bignumber.js";
import "lodash/flatten.js";
import * as tslib_1 from "tslib";
import freighterApi from "@stellar/freighter-api";
import LedgerStr from "@ledgerhq/hw-app-str";
import LedgerTransport from "@ledgerhq/hw-transport-u2f";
import TrezorConnect from "trezor-connect";
import scrypt from "scrypt-async";
import nacl from "tweetnacl";
import naclutil from "tweetnacl-util";
import queryString from "query-string";
import isEqual from "lodash/isEqual.js";
var EffectType;
(function(EffectType2) {
  EffectType2["account_created"] = "account_created";
  EffectType2["account_credited"] = "account_credited";
  EffectType2["account_debited"] = "account_debited";
  EffectType2["account_home_domain_updated"] = "account_home_domain_updated";
  EffectType2["account_inflation_destination_updated"] = "account_inflation_destination_updated";
  EffectType2["account_removed"] = "account_removed";
  EffectType2["account_thresholds_updated"] = "account_thresholds_updated";
  EffectType2["signer_created"] = "signer_created";
  EffectType2["signer_removed"] = "signer_removed";
  EffectType2["signer_updated"] = "signer_updated";
  EffectType2["trade"] = "trade";
  EffectType2["trustline_created"] = "trustline_created";
  EffectType2["trustline_removed"] = "trustline_removed";
  EffectType2["trustline_updated"] = "trustline_updated";
})(EffectType || (EffectType = {}));
var KeyType;
(function(KeyType2) {
  KeyType2["albedo"] = "albedo";
  KeyType2["ledger"] = "ledger";
  KeyType2["freighter"] = "freighter";
  KeyType2["plaintextKey"] = "plaintextKey";
  KeyType2["trezor"] = "trezor";
})(KeyType || (KeyType = {}));
var TransferResponseType;
(function(TransferResponseType2) {
  TransferResponseType2["ok"] = "ok";
  TransferResponseType2["non_interactive_customer_info_needed"] = "non_interactive_customer_info_needed";
  TransferResponseType2["interactive_customer_info_needed"] = "interactive_customer_info_needed";
  TransferResponseType2["customer_info_status"] = "customer_info_status";
  TransferResponseType2["error"] = "error";
})(TransferResponseType || (TransferResponseType = {}));
var TransactionStatus;
(function(TransactionStatus2) {
  TransactionStatus2["incomplete"] = "incomplete";
  TransactionStatus2["pending_user_transfer_start"] = "pending_user_transfer_start";
  TransactionStatus2["pending_user_transfer_complete"] = "pending_user_transfer_complete";
  TransactionStatus2["pending_external"] = "pending_external";
  TransactionStatus2["pending_anchor"] = "pending_anchor";
  TransactionStatus2["pending_stellar"] = "pending_stellar";
  TransactionStatus2["pending_trust"] = "pending_trust";
  TransactionStatus2["pending_user"] = "pending_user";
  TransactionStatus2["completed"] = "completed";
  TransactionStatus2["refunded"] = "refunded";
  TransactionStatus2["no_market"] = "no_market";
  TransactionStatus2["too_small"] = "too_small";
  TransactionStatus2["too_large"] = "too_large";
  TransactionStatus2["error"] = "error";
})(TransactionStatus || (TransactionStatus = {}));
var ApprovalResponseStatus;
(function(ApprovalResponseStatus2) {
  ApprovalResponseStatus2["success"] = "success";
  ApprovalResponseStatus2["revised"] = "revised";
  ApprovalResponseStatus2["pending"] = "pending";
  ApprovalResponseStatus2["actionRequired"] = "action_required";
  ApprovalResponseStatus2["rejected"] = "rejected";
})(ApprovalResponseStatus || (ApprovalResponseStatus = {}));
var ActionResult;
(function(ActionResult2) {
  ActionResult2["noFurtherActionRequired"] = "no_further_action_required";
  ActionResult2["followNextUrl"] = "follow_next_url";
})(ActionResult || (ActionResult = {}));
function generateRandomToken() {
  const rn = new Uint32Array(4);
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    crypto.getRandomValues(rn);
  } else {
    for (let i = 0; i < rn.length; i++) {
      rn[i] = Math.floor(Math.random() * 4294967295);
    }
  }
  return Array.from(rn).map((n) => n.toString(36)).join("");
}
const intentInterface = {
  public_key: {
    risk: "low",
    title: "View public key",
    description: "Requests account public key. It's a simple way of authentication for Stellar-based applications. The response ensures that a user owns the corresponding secret key.",
    unsafe: false,
    implicitFlow: false,
    params: {
      token: {
        description: "Verification token generated by the application (should be unique or random).",
        required: false
      }
    },
    returns: ["pubkey", "signed_message", "signature"]
  },
  sign_message: {
    risk: "medium",
    title: "Sign text message",
    description: "Requests arbitrary message signing. Can be used to implement identity/ownership verification.",
    unsafe: false,
    implicitFlow: true,
    params: {
      message: {
        description: "Text message to sign.",
        required: true
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        required: false
      }
    },
    returns: ["pubkey", "message", "original_message", "message_signature"]
  },
  tx: {
    risk: "high",
    title: "Sign transaction",
    description: "Requests a signature for the transaction. Returns signed transaction envelope that can be submitted to the network or used for multi-sig coordination.",
    unsafe: true,
    implicitFlow: true,
    params: {
      xdr: {
        description: "XDR-encoded transaction envelope to sign.",
        required: true
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        required: false
      },
      network: {
        description: "Stellar network identifier or private network passphrase.",
        required: false
      },
      horizon: {
        description: "The URL of the Horizon server.",
        required: false
      },
      callback: {
        description: "Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        required: false,
        type: Boolean
      }
    },
    returns: ["xdr", "signed_envelope_xdr", "pubkey", "tx_signature", "network", "submit"]
  },
  pay: {
    risk: "high",
    title: "Make payment",
    description: "Requests a payment from a user. Works with any Stellar asset, supports transaction memo.",
    unsafe: false,
    implicitFlow: true,
    params: {
      amount: {
        description: "Requested payment amount.",
        required: true
      },
      destination: {
        description: "Payment destination.",
        required: true
      },
      asset_code: {
        description: "Asset code (skip for XLM).",
        required: false
      },
      asset_issuer: {
        description: "Asset issuer (skip for XLM).",
        required: false
      },
      memo: {
        description: "Transaction memo (required for exchanges and some anchors).",
        required: false
      },
      memo_type: {
        description: "Transaction memo type.",
        required: false
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        required: false
      },
      network: {
        description: "Stellar network identifier or private network passphrase.",
        required: false
      },
      horizon: {
        description: "The URL of the Horizon server.",
        required: false
      },
      callback: {
        description: "Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        required: false,
        type: Boolean
      }
    },
    returns: ["amount", "destination", "asset_code", "asset_issuer", "memo", "memo_type", "signed_envelope_xdr", "pubkey", "tx_signature", "network", "horizon"]
  },
  trust: {
    risk: "low",
    title: "Establish trustline",
    description: "Requests permission to create a trustline to a given Stellar asset. Gradually simplifies the process of creating trustlines for anchors, ICOs, and airdrops.",
    unsafe: false,
    implicitFlow: true,
    params: {
      asset_code: {
        description: "Trustline asset code.",
        required: true
      },
      asset_issuer: {
        description: "Trustline asset issuer address.",
        required: true
      },
      limit: {
        description: "Trust limit.",
        required: false
      },
      memo: {
        description: "Transaction memo (required for exchanges and some anchors).",
        required: false
      },
      memo_type: {
        description: "Transaction memo type.",
        required: false
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        required: false
      },
      network: {
        description: "Stellar network identifier or private network passphrase.",
        required: false
      },
      horizon: {
        description: "The URL of the Horizon server.",
        required: false
      },
      callback: {
        description: "Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        required: false,
        type: Boolean
      }
    },
    returns: ["asset_code", "asset_issuer", "limit", "memo", "memo_type", "signed_envelope_xdr", "pubkey", "tx_signature", "network", "horizon"]
  },
  exchange: {
    risk: "high",
    title: "Purchase tokens",
    description: "Requests permission to buy tokens on Stellar DEX at market price.",
    unsafe: true,
    implicitFlow: false,
    params: {
      sell_asset_code: {
        description: "Asset code of the asset to sell.",
        required: false
      },
      sell_asset_issuer: {
        description: "Issuer account of the asset to sell.",
        required: false
      },
      buy_asset_code: {
        description: "Asset code of the asset to buy.",
        required: false
      },
      buy_asset_issuer: {
        description: "Issuer account of the asset to buy.",
        required: false
      },
      amount: {
        description: "The amount of asset to buy.",
        required: true
      },
      max_price: {
        description: "Maximum price the user willing to pay.",
        required: true
      },
      memo: {
        description: "Transaction memo (required for exchanges and some anchors).",
        required: false
      },
      memo_type: {
        description: "Transaction memo type.",
        required: false
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        required: false
      },
      network: {
        description: "Stellar network identifier or private network passphrase.",
        required: false
      },
      horizon: {
        description: "The URL of the Horizon server.",
        required: false
      },
      callback: {
        description: "Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        required: false,
        type: Boolean
      }
    },
    returns: ["amount", "max_price", "sell_asset_code", "sell_asset_issuer", "buy_asset_code", "buy_asset_issuer", "memo", "memo_type", "signed_envelope_xdr", "pubkey", "tx_signature", "network", "horizon"]
  },
  implicit_flow: {
    risk: "high",
    title: "Implicit permissions",
    description: 'Requests temporary access token for one or more intents that can be used to execute actions without explicit confirmation from the user. In order to be executed implicitly, an implicit flow permissions for a given intent should be granted and "pubkey" parameter set.',
    unsafe: true,
    implicitFlow: false,
    params: {
      intents: {
        description: "Requested intents for the implicit flow.",
        required: true
      },
      network: {
        description: "Stellar network identifier or private network passphrase.",
        required: false
      }
    },
    returns: ["granted", "intents", "grants", "session", "pubkey", "network", "valid_until"]
  }
};
const intentErrors = {
  unhandledError: {
    message: "Unhandled error occurred. If this error persists, please contact Albedo support.",
    code: -1
  },
  externalError: {
    message: "External error occurred.",
    code: -2
  },
  invalidIntentRequest: {
    message: "Intent request is invalid.",
    code: -3
  },
  actionRejectedByUser: {
    message: "Action request was rejected by the user.",
    code: -4
  },
  horizonError: {
    message: "Transaction failed when submitted to Stellar network.",
    code: -5
  },
  callbackError: {
    message: "Callback redirect failed.",
    code: -6
  }
};
const name = "@albedo-link/intent";
const version = "0.9.6";
const description = "A lightweight browser wrapper for Albedo API that provides a promise-based interface for all supported intents.";
const author = "StellarExpertTeam<info@stellar.expert>";
const license = "MIT";
const homepage = "https://github.com/stellar-expert/albedo";
const bugs = {
  url: "https://github.com/stellar-expert/albedo/issues",
  email: "info@stellar.expert"
};
const repository = {
  type: "git",
  url: "https://github.com/stellar-expert/albedo.git"
};
const scripts = {
  postbuild: "node ./build/update-readme.js",
  build: "webpack --mode=production --config ./webpack.config.js",
  test: "./node_modules/.bin/mocha --require @babel/register"
};
const main = "./lib/albedo.intent.js";
const module = "./src/index.js";
const keywords = [
  "stellar",
  "SSO",
  "signer",
  "intent",
  "multi-sig"
];
const devDependencies = {
  "@babel/core": "^7.11.6",
  "@babel/plugin-proposal-class-properties": "^7.10.4",
  "@babel/plugin-proposal-decorators": "^7.10.5",
  "@babel/plugin-proposal-object-rest-spread": "^7.11.0",
  "@babel/plugin-proposal-private-methods": "^7.10.4",
  "@babel/plugin-syntax-dynamic-import": "^7.8.3",
  "@babel/preset-env": "^7.11.5",
  "@babel/register": "^7.11.5",
  "babel-loader": "^8.1.0",
  chai: "^4.2.0",
  esm: "^3.2.25",
  mocha: "^8.1.3",
  sinon: "^9.1.0",
  "terser-webpack-plugin": "^4.2.2",
  webpack: "^4.44.2",
  "webpack-cli": "^3.3.12"
};
const pkgInfo = {
  name,
  version,
  description,
  author,
  license,
  homepage,
  bugs,
  repository,
  scripts,
  main,
  module,
  keywords,
  devDependencies
};
function TransportHandler(targetWindow, ephemeral = false) {
  this.windowHandler = targetWindow;
  this.ephemeral = !!ephemeral;
  this.isLoaded = false;
  this.pendingRequests = {};
  this.preprocessRequestParams = null;
  this.onLoaded = new Promise((resolve, reject) => this.onLoadedCallback = resolve).then(() => this);
  this.messageHandler = this.messageHandler.bind(this);
  window.addEventListener("message", this.messageHandler, false);
}
TransportHandler.prototype = {
  isLoaded: false,
  markLoaded() {
    const { onLoadedCallback } = this;
    if (onLoadedCallback) {
      this.onLoadedCallback = null;
      this.isLoaded = true;
      onLoadedCallback();
    }
  },
  /**
   * Handler for incoming communication messages processing.
   * @param {Object} data - Received data.
   */
  messageHandler({ data }) {
    if (data.albedo) {
      data.albedo;
      return this.markLoaded();
    }
    if (data.albedoIntentResult) {
      const { __reqid, ...result } = data.albedoIntentResult, pending = this.pendingRequests[__reqid];
      if (pending) {
        delete this.pendingRequests[__reqid];
        pending(result.error, result);
        if (this.ephemeral) {
          window.removeEventListener("message", this.messageHandler, false);
          this.windowHandler.close();
        }
      }
    }
  },
  /**
   * Handler for the transport window close event.
   */
  transportCloseHandler() {
    for (let key in this.pendingRequests)
      if (this.pendingRequests.hasOwnProperty(key)) {
        const pending = this.pendingRequests[key];
        delete this.pendingRequests[key];
        pending(intentErrors.actionRejectedByUser);
      }
  },
  /**
   * Request intent confirmation using current transport.
   * @param {Object} params - Intent request params.
   * @return {Promise}
   */
  postMessage(params) {
    const nonce = generateRandomToken();
    return new Promise((resolve, reject) => {
      this.onLoaded.then(() => {
        this.pendingRequests[nonce] = (err, data) => err ? reject(err) : resolve(data);
        params = Object.assign({ __reqid: nonce, __albedo_intent_version: pkgInfo.version }, params);
        if (this.preprocessRequestParams) {
          params = this.preprocessRequestParams(params);
        }
        this.windowHandler.postMessage(params, "*");
      });
    });
  }
};
function createDialogTransport(frontendUrl) {
  const url = `${frontendUrl}/confirm`, w = 440, h = 600, dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX, dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY, currentWindowWidth = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width, currentWindowHeight = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height, left = currentWindowWidth / 2 - w / 2 + dualScreenLeft, top = currentWindowHeight / 2 - h / 2 + dualScreenTop;
  const dialogWindow = window.open(url, "auth.albedo.link", `height=${h},width=${w},top=${top},left=${left},menubar=0,toolbar=0,location=0,status=0,personalbar=0,scrollbars=0,dependent=1`);
  return new TransportHandler(dialogWindow, true).onLoaded;
}
let sharedIframeTransport = null;
function createIframeTransport(frontendUrl) {
  if (!sharedIframeTransport) {
    const iframe = document.createElement("iframe");
    iframe.style.border = "none";
    Object.assign(iframe, {
      width: "0",
      height: "0",
      frameBorder: "0",
      referrerPolicy: "origin",
      src: `${frontendUrl}`
    });
    document.body.appendChild(iframe);
    sharedIframeTransport = new TransportHandler(iframe.contentWindow);
  }
  return sharedIframeTransport.onLoaded;
}
function ImplicitSession({ session, pubkey, grants, valid_until }) {
  this.key = session;
  this.pubkey = pubkey;
  this.grants = grants.slice();
  this.validUntil = valid_until;
  Object.freeze(this);
  Object.freeze(this.grants);
}
ImplicitSession.prototype = {
  /**
   * Unique session key.
   * @type {String}
   */
  key: "",
  /**
   * Public key of the key pair used to authorize the session.
   * @type {String}
   */
  pubkey: "",
  /**
   * Granted permissions.
   * @type {Array<String>}
   */
  grants: [],
  /**
   * Time-to-live.
   * @type {Number}
   */
  validUntil: 0,
  /**
   * Check whether the session is expired or not.
   * @return {boolean}
   */
  get isExpired() {
    return this.validUntil - 2e3 < (/* @__PURE__ */ new Date()).getTime();
  },
  toJSON() {
    return {
      session: this.key,
      pubkey: this.pubkey,
      grants: this.grants.slice(),
      valid_until: this.validUntil
    };
  }
};
const storagePrefix = "albedo_session_";
function getStorage() {
  return window.sessionStorage;
}
function saveImplicitSession(intentResult) {
  const session = new ImplicitSession(intentResult);
  {
    getStorage().setItem(storagePrefix + session.pubkey, JSON.stringify(session));
  }
}
function getImplicitSession(intent, pubkey) {
  let session;
  {
    const restored = getStorage().getItem(storagePrefix + pubkey);
    if (restored) {
      session = new ImplicitSession(JSON.parse(restored));
    }
  }
  if (!session)
    return null;
  if (session.isExpired) {
    return null;
  }
  if (!session.grants.includes(intent))
    return null;
  return session;
}
function getAllImplicitSessions() {
  const storage = getStorage();
  return Object.keys(storage).filter((key) => key.indexOf(storagePrefix) === 0).map((key) => JSON.parse(storage.getItem(key)));
}
function requestIntentConfirmation(params, frontendUrl) {
  const { intent } = params;
  if (!intent)
    return Promise.reject(new Error('Parameter "intent" is required.'));
  const intentDescriptor = intentInterface[intent];
  if (!intentDescriptor)
    return Promise.reject(new Error(`Unknown intent: "${intent}".`));
  let requestParams;
  try {
    requestParams = prepareRequestParams(intentDescriptor, params);
  } catch (e) {
    return Promise.reject(e);
  }
  return prepareTransport(requestParams, frontendUrl).then((transport) => sendRequest(requestParams, transport));
}
function prepareTransport(params, frontendUrl) {
  if (params.pubkey) {
    const session = getImplicitSession(params.intent, params.pubkey);
    if (session) {
      params.session = session.key;
      return createIframeTransport(frontendUrl);
    }
  }
  setTimeout(() => {
    if (params.intent === "implicit_flow") {
      createIframeTransport(frontendUrl);
    }
  }, 200);
  return createDialogTransport(frontendUrl);
}
function sendRequest(params, transport) {
  return transport.postMessage(params).then((result) => {
    if (result.intent === "implicit_flow" && result.granted) {
      saveImplicitSession(result);
    }
    return result;
  });
}
function prepareRequestParams(intentDescriptor, params) {
  if (typeof params !== "object")
    throw new Error("Intent parameters expected.");
  const { intent, pubkey } = params, requestParams = { intent };
  if (pubkey && !/^G[0-9A-Z]{55}$/.test(pubkey))
    throw new Error('Invalid "pubkey" parameter. Stellar account public key expected.');
  for (const key in intentDescriptor.params) {
    const props = intentDescriptor.params[key], value = params[key];
    if (value) {
      requestParams[key] = value;
    } else if (props.required) {
      const err = Object.assign(new Error(), intentErrors.invalidIntentRequest);
      err.ext = `Parameter "${key}" is required for intent "${intent}".`;
      throw err;
    }
  }
  return requestParams;
}
function parseQuery(query = null) {
  if (query === null) {
    query = window.location.search;
  }
  if (query[0] === "?")
    query = query.substr(1);
  const dest = {};
  for (let kv of query.split("&")) {
    const [key, value] = kv.split("=").map((v) => decodeURIComponent(v));
    dest[key] = value;
  }
  return dest;
}
function bindWebStellarLinkHandler(albedoIntent) {
  if (typeof document === "undefined" || !document.addEventListener)
    return;
  document.addEventListener("click", function sep0007Handler(e) {
    if (e.target.tagName !== "A" || (e.target.href || "").indexOf("web+stellar:") !== 0)
      return;
    e.preventDefault();
    e.stopImmediatePropagation();
    const { pathname: intentName, search } = new URL(e.target.href);
    if (!["tx", "pay"].includes(intentName)) {
      alert(`Invalid operation requested: ${intentName}. It's likely an external application error. Please contact support team of ${window.location.origin}.`);
      return;
    }
    const params = parseQuery(search);
    albedoIntent.request(intentName, params);
  }, false);
}
if (typeof window === "object" && typeof window.fetch !== "function") {
  throw new Error("Browser FetchAPI is not available. For legacy browsers support use polyfills such as whatwg-fetch.");
}
function AlbedoIntent() {
  this.frontendUrl = "https://albedo.link";
}
AlbedoIntent.prototype = {
  frontendUrl: "https://albedo.link",
  /**
   * Initiate external intent request.
   * @param {String} intent - Intent name.
   * @param {Object} [params] - Request parameters.
   * @returns {Promise<Object>}
   */
  request(intent, params) {
    return requestIntentConfirmation(Object.assign(params || {}, { intent }), this.frontendUrl);
  },
  /**
   * Requests temporary permissions to execute the specific intents without calling confirmation dialog.
   * @param {Object} params - Intent parameters.
   * @param {Array<String>} params.intents - Requested intents.
   */
  implicitFlow(params) {
    return this.request("implicit_flow", params);
  },
  /**
   * Request secure third-party application authentication.
   * @param {Object} params - Intent parameters.
   * @param {String} [params.token] - Verification token generated by the application (should be unique or random).
   * @returns {Promise<Object>}
   */
  publicKey(params) {
    params = Object.assign({}, params);
    if (!params.token) {
      params.token = generateRandomToken();
    }
    return this.request("public_key", params);
  },
  /**
   * Request transaction signing, returns signed transaction envelope.
   * @param {Object} params - Intent parameters.
   * @param {String} params.xdr - A Stellar transaction in XDR format encoded in base64.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @param {String} [params.network] - Stellar account network identifier or private network passphrase.
   * @param {String} [params.horizon] - The URL of the Horizon server.
   * @param {Boolean} [params.submit] - If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.
   * @returns {Promise<Object>}
   */
  tx(params) {
    return this.request("tx", params);
  },
  /**
   * Request an asset trustline creation.
   * @param {Object} params - Intent parameters.
   * @param {String} params.destination - Payment destination address.
   * @param {String} params.amount - Amount to pay.
   * @param {String} [params.asset_code] - [Optional] Asset code (if not set XLM is implied).
   * @param {String} [params.asset_issuer] - [Optional] Asset issuer (if not set XLM is implied).
   * @param {String} [params.memo] - [Optional] Memo to be included in the payment.
   * @param {('MEMO_TEXT' | 'MEMO_ID' | 'MEMO_HASH' | 'MEMO_RETURN')} [params.memo_type] - [Optional] Memo type to be included in the payment.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @param {String} [params.network] - Stellar account network identifier or private network passphrase.
   * @param {String} [params.horizon] - The URL of the Horizon server.
   * @param {Boolean} [params.submit] - If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.
   * @returns {Promise<Object>}
   */
  pay(params) {
    return this.request("pay", params);
  },
  /**
   * Request an asset trustline creation.
   * @param {Object} params - Intent parameters.
   * @param {String} params.asset_code - Asset code.
   * @param {String} params.asset_issuer - Asset account issuer.
   * @param {String} [params.limit] - [Optional] Trustline limit.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @param {String} [params.network] - Stellar account network identifier or private network passphrase.
   * @param {String} [params.horizon] - The URL of the Horizon server.
   * @param {Boolean} [params.submit] - If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.
   * @returns {Promise<Object>}
   */
  trust(params) {
    return this.request("trust", params);
  },
  /**
   * Request token exchange on Stellar DEX.
   * @param {Object} params - Intent parameters.
   * @param {String} params.destination - Payment destination address.
   * @param {String} params.amount - Amount to pay.
   * @param {String} params.max_price - Maximum price to pay.
   * @param {String} [params.sell_asset_code] - [Optional] Selling asset code (if not set XLM is implied).
   * @param {String} [params.sell_asset_issuer] - [Optional] Selling asset issuer (if not set XLM is implied).
   * @param {String} [params.buy_asset_code] - [Optional] Selling asset code (if not set XLM is implied).
   * @param {String} [params.buy_asset_issuer] - [Optional] Selling asset issuer (if not set XLM is implied).
   * @return {Promise<Object>}
   */
  exchange(params) {
    return this.request("exchange", params);
  },
  /**
   * Request arbitrary data signing.
   * @param {Object} params - Intent parameters.
   * @param {String} params.message - Text message to sign.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @returns {Promise<Object>}
   */
  signMessage(params) {
    params = Object.assign({}, params, { message: normalizeMessageToSign(params.message) });
    return this.request("sign_message", params);
  },
  generateRandomToken() {
    return generateRandomToken();
  },
  /**
   * Check whether an implicit session exists for a given intent and pubkey.
   * @param {String} intent
   * @param {String} pubkey
   * @return {boolean}
   */
  isImplicitSessionAllowed(intent, pubkey) {
    return !!getImplicitSession(intent, pubkey);
  },
  /**
   * Enumerate all currently active implicit sessions.
   * @returns {Array<{pubkey: String, session: String, valid_until: Number, grants: Array<String>}>}
   */
  listImplicitSessions() {
    return getAllImplicitSessions();
  },
  /**
   * Revoke session permission granted for an account.
   * @param {String} pubkey
   */
  forgetImplicitSession(pubkey) {
    forgetSession(pubkey);
  }
};
function normalizeMessageToSign(message) {
  switch (typeof message) {
    case "string":
      return message;
    case "undefined":
      return "";
  }
  return JSON.stringify(message);
}
AlbedoIntent.intentInterface = intentInterface;
AlbedoIntent.intentErrors = intentErrors;
const albedo = new AlbedoIntent();
bindWebStellarLinkHandler(albedo);
var albedoHandler = {
  keyType: KeyType.albedo,
  signTransaction: function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var transaction, key, xdr, response, error_1;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            transaction = params.transaction, key = params.key;
            if (key.privateKey !== "") {
              throw new Error("Non-ledger key sent to ledger handler: " + JSON.stringify(key.publicKey));
            }
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            xdr = transaction.toXDR();
            return [4, albedo.tx({ xdr })];
          case 2:
            response = _a.sent();
            if (!response.signed_envelope_xdr) {
              throw new Error("We couldn’t sign the transaction with Albedo.");
            }
            return [2, TransactionBuilder.fromXDR(response.signed_envelope_xdr, Networks.PUBLIC)];
          case 3:
            error_1 = _a.sent();
            throw new Error("We couldn’t sign the transaction with Albedo. " + error_1.toString() + ".");
          case 4:
            return [2];
        }
      });
    });
  }
};
var freighterHandler = {
  keyType: KeyType.freighter,
  signTransaction: function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var transaction, key, custom, response, error_1;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            transaction = params.transaction, key = params.key, custom = params.custom;
            if (key.privateKey !== "") {
              throw new Error("Non-ledger key sent to ledger handler: " + JSON.stringify(key.publicKey));
            }
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, freighterApi.signTransaction(transaction.toXDR(), custom && custom.network ? custom.network : void 0)];
          case 2:
            response = _a.sent();
            return [2, TransactionBuilder.fromXDR(response, Networks.PUBLIC)];
          case 3:
            error_1 = _a.sent();
            throw new Error("We couldn’t sign the transaction with Freighter. " + error_1.toString() + ".");
          case 4:
            return [2];
        }
      });
    });
  }
};
var ledgerHandler = {
  keyType: KeyType.ledger,
  signTransaction: function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var transaction, key, transport, ledgerApi, result, keyPair, decoratedSignature;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            transaction = params.transaction, key = params.key;
            if (key.privateKey !== "") {
              throw new Error("Non-ledger key sent to ledger handler: " + JSON.stringify(key.publicKey));
            }
            return [4, LedgerTransport.create(60 * 1e3)];
          case 1:
            transport = _a.sent();
            ledgerApi = new LedgerStr(transport);
            return [4, ledgerApi.signTransaction(key.path, transaction.signatureBase())];
          case 2:
            result = _a.sent();
            keyPair = StellarSdk.Keypair.fromPublicKey(key.publicKey);
            decoratedSignature = new StellarSdk.xdr.DecoratedSignature({
              hint: keyPair.signatureHint(),
              signature: result.signature
            });
            transaction.signatures.push(decoratedSignature);
            return [2, Promise.resolve(transaction)];
        }
      });
    });
  }
};
var plaintextKeyHandler = {
  keyType: KeyType.ledger,
  signTransaction: function(params) {
    var transaction = params.transaction, key = params.key;
    if (key.privateKey === "") {
      throw new Error("Non-plaintext key sent to plaintext handler: " + JSON.stringify(key.publicKey));
    }
    var keyPair = StellarSdk.Keypair.fromSecret(key.privateKey);
    transaction.sign(keyPair);
    return Promise.resolve(transaction);
  }
};
var transformSigner = function(signer) {
  var type = 0;
  var key;
  var weight = signer.weight;
  if (typeof signer.ed25519PublicKey === "string") {
    var keyPair = StellarSdk.Keypair.fromPublicKey(signer.ed25519PublicKey);
    key = keyPair.rawPublicKey().toString("hex");
  }
  if (signer.preAuthTx instanceof Buffer) {
    type = 1;
    key = signer.preAuthTx.toString("hex");
  }
  if (signer.sha256Hash instanceof Buffer) {
    type = 2;
    key = signer.sha256Hash.toString("hex");
  }
  return {
    type,
    key,
    weight
  };
};
var transformAsset = function(asset) {
  if (asset.isNative()) {
    return {
      type: 0,
      code: asset.getCode()
    };
  }
  return {
    type: asset.getAssetType() === "credit_alphanum4" ? 1 : 2,
    code: asset.getCode(),
    issuer: asset.getIssuer()
  };
};
var transformAmount = function(amount) {
  return new BigNumber(amount).times(1e7).toString();
};
var transformType = function(type) {
  switch (type) {
    case "pathPaymentStrictReceive":
      return "pathPayment";
    case "createPassiveSellOffer":
      return "createPassiveOffer";
    case "manageSellOffer":
      return "manageOffer";
    default:
      return type;
  }
};
var transformMemo = function(memo) {
  switch (memo.type) {
    case StellarSdk.MemoText:
      return { type: 1, text: memo.value };
    case StellarSdk.MemoID:
      return { type: 2, id: memo.value };
    case StellarSdk.MemoHash:
      return { type: 3, hash: memo.value ? memo.value.toString("hex") : "" };
    case StellarSdk.MemoReturn:
      return { type: 4, hash: memo.value ? memo.value.toString("hex") : "" };
    default:
      return { type: 0 };
  }
};
var transformTimebounds = function(timebounds) {
  if (!timebounds) {
    return void 0;
  }
  return {
    minTime: Number.parseInt(timebounds.minTime, 10),
    maxTime: Number.parseInt(timebounds.maxTime, 10)
  };
};
var transformTransaction = function(path, transaction) {
  var amounts = [
    "amount",
    "sendMax",
    "destAmount",
    "startingBalance",
    "limit"
  ];
  var assets = [
    "asset",
    "sendAsset",
    "destAsset",
    "selling",
    "buying",
    "line"
  ];
  var operations = transaction.operations.map(function(o, i) {
    var operation = tslib_1.__assign({}, o);
    if (operation.signer) {
      operation.signer = transformSigner(operation.signer);
    }
    if (operation.path) {
      operation.path = operation.path.map(transformAsset);
    }
    if (typeof operation.price === "string") {
      var xdrOperation = transaction.tx.operations()[i];
      operation.price = {
        n: xdrOperation.body().value().price().n(),
        d: xdrOperation.body().value().price().d()
      };
    }
    amounts.forEach(function(field) {
      if (typeof operation[field] === "string") {
        operation[field] = transformAmount(operation[field]);
      }
    });
    assets.forEach(function(field) {
      if (operation[field]) {
        operation[field] = transformAsset(operation[field]);
      }
    });
    if (operation.type === "allowTrust") {
      var allowTrustAsset = new StellarSdk.Asset(operation.assetCode, operation.trustor);
      operation.assetType = transformAsset(allowTrustAsset).type;
    }
    if (operation.type === "manageData" && operation.value) {
      operation.value = operation.value.toString("hex");
    }
    operation.type = transformType(o.type);
    return operation;
  });
  return {
    path,
    networkPassphrase: transaction.networkPassphrase,
    transaction: {
      source: transaction.source,
      fee: Number(transaction.fee),
      sequence: transaction.sequence,
      memo: transformMemo(transaction.memo),
      timebounds: transformTimebounds(transaction.timeBounds),
      operations
    }
  };
};
var trezorHandler = {
  keyType: KeyType.trezor,
  signTransaction: function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var transaction, key, custom, trezorParams, response, signature, error_1;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            transaction = params.transaction, key = params.key, custom = params.custom;
            if (key.privateKey !== "") {
              throw new Error("Non-ledger key sent to ledger handler: " + JSON.stringify(key.publicKey));
            }
            if (!custom || !custom.email || !custom.appUrl) {
              throw new Error('Trezor Connect manifest with "email" and "appUrl" props is required.\n        Make sure they are passed through "custom" prop.');
            }
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            TrezorConnect.manifest({
              email: custom.email,
              appUrl: custom.appUrl
            });
            trezorParams = transformTransaction("m/44'/148'/0'", transaction);
            return [4, TrezorConnect.stellarSignTransaction(trezorParams)];
          case 2:
            response = _a.sent();
            if (response.success) {
              signature = Buffer.from(response.payload.signature, "hex").toString("base64");
              transaction.addSignature(key.publicKey, signature);
              return [2, transaction];
            }
            throw new Error(response.payload.error || "We couldn’t sign the transaction with Trezor.");
          case 3:
            error_1 = _a.sent();
            throw new Error("We couldn’t sign the transaction with Trezor. " + error_1.toString() + ".");
          case 4:
            return [2];
        }
      });
    });
  }
};
var KeyManager = function() {
  function KeyManager2(params) {
    var _a;
    this.encrypterMap = {};
    this.keyHandlerMap = (_a = {}, _a[KeyType.albedo] = albedoHandler, _a[KeyType.ledger] = ledgerHandler, _a[KeyType.freighter] = freighterHandler, _a[KeyType.plaintextKey] = plaintextKeyHandler, _a[KeyType.trezor] = trezorHandler, _a);
    this.keyCache = {};
    this.keyStore = params.keyStore;
    this.shouldCache = params.shouldCache || false;
    this.defaultNetworkPassphrase = params.defaultNetworkPassphrase || StellarSdk.Networks.PUBLIC;
  }
  KeyManager2.prototype.registerKeyHandler = function(keyHandler) {
    this.keyHandlerMap[keyHandler.keyType] = keyHandler;
  };
  KeyManager2.prototype.registerEncrypter = function(encrypter) {
    this.encrypterMap[encrypter.name] = encrypter;
  };
  KeyManager2.prototype.setDefaultNetworkPassphrase = function(passphrase) {
    this.defaultNetworkPassphrase = passphrase;
  };
  KeyManager2.prototype.storeKey = function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var key, password, encrypterName, id, newKey, encrypter, encryptedKey, keyMetadata;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            key = params.key, password = params.password, encrypterName = params.encrypterName;
            id = key.id || "" + Math.random();
            newKey = tslib_1.__assign({}, key, { id });
            encrypter = this.encrypterMap[encrypterName];
            return [4, encrypter.encryptKey({
              key: newKey,
              password
            })];
          case 1:
            encryptedKey = _a.sent();
            return [4, this.keyStore.storeKeys([encryptedKey])];
          case 2:
            keyMetadata = _a.sent();
            this._writeIndexCache(newKey.id, newKey);
            return [2, keyMetadata[0]];
        }
      });
    });
  };
  KeyManager2.prototype.loadKey = function(id, password) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var encryptedKeys, keys, encryptedKey, encrypter, key;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.keyStore.loadAllKeys()];
          case 1:
            encryptedKeys = _a.sent();
            keys = encryptedKeys.filter(function(k) {
              return k.id === id;
            });
            if (!keys.length) {
              throw new Error("Key not found with id '" + id + "'.");
            }
            if (keys.length > 1) {
              throw new Error("Too many keys found with id '" + id + "', that’s not supposed to happen!");
            }
            encryptedKey = keys[0];
            encrypter = this.encrypterMap[encryptedKey.encrypterName];
            _a.label = 2;
          case 2:
            _a.trys.push([2, 4, , 5]);
            return [4, encrypter.decryptKey({
              encryptedKey,
              password
            })];
          case 3:
            key = _a.sent();
            return [3, 5];
          case 4:
            _a.sent();
            throw new Error("Couldn’t decrypt key '" + id + "' with the supplied password.");
          case 5:
            return [2, key];
        }
      });
    });
  };
  KeyManager2.prototype.loadAllKeyIds = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var encryptedKeys;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.keyStore.loadAllKeys()];
          case 1:
            encryptedKeys = _a.sent();
            return [2, encryptedKeys.map(function(key) {
              return key.id;
            })];
        }
      });
    });
  };
  KeyManager2.prototype.removeKey = function(id) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var res;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.keyStore.removeKey(id)];
          case 1:
            res = _a.sent();
            this._writeIndexCache(id, void 0);
            return [2, res];
        }
      });
    });
  };
  KeyManager2.prototype.signTransaction = function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var transaction, id, password, custom, key, encryptedKey, encrypter, keyHandler, signedTransaction;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            transaction = params.transaction, id = params.id, password = params.password, custom = params.custom;
            key = this._readFromCache(id);
            if (!!key)
              return [3, 3];
            return [4, this.keyStore.loadKey(id)];
          case 1:
            encryptedKey = _a.sent();
            if (!encryptedKey) {
              throw new Error("Couldn't sign the transaction: no key with id '" + id + "' found.");
            }
            encrypter = this.encrypterMap[encryptedKey.encrypterName];
            return [4, encrypter.decryptKey({ encryptedKey, password })];
          case 2:
            key = _a.sent();
            this._writeIndexCache(id, key);
            _a.label = 3;
          case 3:
            keyHandler = this.keyHandlerMap[key.type];
            return [4, keyHandler.signTransaction({
              transaction,
              key,
              custom
            })];
          case 4:
            signedTransaction = _a.sent();
            return [2, signedTransaction];
        }
      });
    });
  };
  KeyManager2.prototype.fetchAuthToken = function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var id, password, authServer, authServerKey, authServerHomeDomains, clientDomain, _a, onChallengeTransactionSignature, account, key, encryptedKey, encrypter, challengeUrl, challengeRes, challengeText, keyNetwork, text, json, transaction, keyHandler, signedTransaction, signedTransactionXDR, responseRes, responseText, responseJson, responseResText, _b, token, message, status_1;
      return tslib_1.__generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            id = params.id, password = params.password, authServer = params.authServer, authServerKey = params.authServerKey, authServerHomeDomains = params.authServerHomeDomains, clientDomain = params.clientDomain, _a = params.onChallengeTransactionSignature, onChallengeTransactionSignature = _a === void 0 ? function(tx) {
              return Promise.resolve(tx);
            } : _a;
            account = params.account;
            if (id === void 0) {
              throw new Error("Required parameter `id` is missing!");
            }
            if (password === void 0) {
              throw new Error("Required parameter `password` is missing!");
            }
            if (!authServer) {
              throw new Error("Required parameter `authServer` is missing!");
            }
            if (!authServerKey) {
              throw new Error("Required parameter `authServerKey` is missing!");
            }
            if (!authServerHomeDomains) {
              throw new Error("Required parameter `authServerHomeDomains` is missing!");
            }
            key = this._readFromCache(id);
            if (!!key)
              return [3, 3];
            return [4, this.keyStore.loadKey(id)];
          case 1:
            encryptedKey = _c.sent();
            if (!encryptedKey) {
              throw new Error("Couldn't fetch an auth token: no key with id '" + id + "' found.");
            }
            encrypter = this.encrypterMap[encryptedKey.encrypterName];
            return [4, encrypter.decryptKey({ encryptedKey, password })];
          case 2:
            key = _c.sent();
            this._writeIndexCache(id, key);
            _c.label = 3;
          case 3:
            account = account || key.publicKey;
            challengeUrl = authServer + "?account=" + encodeURIComponent(account);
            if (clientDomain) {
              challengeUrl += "&client_domain=" + encodeURIComponent(clientDomain);
            }
            return [4, fetch(challengeUrl)];
          case 4:
            challengeRes = _c.sent();
            if (!(challengeRes.status !== 200))
              return [3, 6];
            return [4, challengeRes.text()];
          case 5:
            challengeText = _c.sent();
            throw new Error("[KeyManager#fetchAuthToken] Failed to fetch a challenge transaction,\n          error: " + JSON.stringify(challengeText));
          case 6:
            keyNetwork = key.network || this.defaultNetworkPassphrase;
            return [4, challengeRes.text()];
          case 7:
            text = _c.sent();
            try {
              json = JSON.parse(text);
            } catch (e) {
              throw new Error("Request for challenge returned invalid JSON: " + text);
            }
            if (json.error) {
              throw new Error(json.error);
            }
            if (json.network_passphrase !== void 0 && keyNetwork !== json.network_passphrase) {
              throw new Error('Network mismatch: the transfer server expects "' + json.network_passphrase + `", but you're using "` + keyNetwork + '"');
            }
            transaction = Utils.readChallengeTx(json.transaction, authServerKey, keyNetwork, authServerHomeDomains, new URL(authServer).hostname).tx;
            return [4, onChallengeTransactionSignature(transaction)];
          case 8:
            transaction = _c.sent();
            keyHandler = this.keyHandlerMap[key.type];
            return [4, keyHandler.signTransaction({
              transaction,
              key
            })];
          case 9:
            signedTransaction = _c.sent();
            signedTransactionXDR = signedTransaction.toEnvelope().toXDR().toString("base64");
            return [4, fetch(authServer, {
              method: "POST",
              body: JSON.stringify({
                transaction: signedTransactionXDR
              }),
              headers: {
                "Content-Type": "application/json"
              }
            })];
          case 10:
            responseRes = _c.sent();
            if (!(responseRes.status !== 200))
              return [3, 12];
            return [4, responseRes.text()];
          case 11:
            responseText = _c.sent();
            try {
              responseJson = JSON.parse(responseText);
              throw new Error("[KeyManager#fetchAuthToken] Failed to return a signed transaction,\n          error: " + responseJson.error);
            } catch (e) {
              throw new Error("[KeyManager#fetchAuthToken] Failed to return a signed transaction,\n          error code " + responseRes.status + ' and status text\n          "' + responseText + '"');
            }
            _c.label = 12;
          case 12:
            return [4, responseRes.text()];
          case 13:
            responseResText = _c.sent();
            try {
              _b = JSON.parse(responseResText), token = _b.token, message = _b.message, status_1 = _b.status;
              if (status_1 === false && message) {
                throw new Error(message);
              }
              return [2, token];
            } catch (e) {
              throw new Error("[KeyManager#fetchAuthToken] Failed to validate signed transaction\n        response, server responded with " + responseResText);
            }
            return [2];
        }
      });
    });
  };
  KeyManager2.prototype.changePassword = function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var oldPassword, newPassword, oldKeys, newKeys;
      var _this = this;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            oldPassword = params.oldPassword, newPassword = params.newPassword;
            return [4, this.keyStore.loadAllKeys()];
          case 1:
            oldKeys = _a.sent();
            return [4, Promise.all(oldKeys.map(function(encryptedKey) {
              return tslib_1.__awaiter(_this, void 0, void 0, function() {
                var encrypter, decryptedKey;
                return tslib_1.__generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      encrypter = this.encrypterMap[encryptedKey.encrypterName];
                      return [4, encrypter.decryptKey({
                        encryptedKey,
                        password: oldPassword
                      })];
                    case 1:
                      decryptedKey = _a2.sent();
                      this._writeIndexCache(decryptedKey.id, decryptedKey);
                      return [2, encrypter.encryptKey({
                        key: decryptedKey,
                        password: newPassword
                      })];
                  }
                });
              });
            }))];
          case 2:
            newKeys = _a.sent();
            return [2, this.keyStore.updateKeys(newKeys)];
        }
      });
    });
  };
  KeyManager2.prototype._readFromCache = function(id) {
    if (!this.shouldCache) {
      return void 0;
    }
    return this.keyCache[id];
  };
  KeyManager2.prototype._writeIndexCache = function(id, key) {
    if (this.shouldCache && key) {
      this.keyCache[id] = key;
    }
  };
  return KeyManager2;
}();
function getKeyMetadata(encryptedKey) {
  var id = encryptedKey.id;
  return {
    id
  };
}
var PREFIX = "stellarkeys";
var BrowserStorageFacade = function() {
  function BrowserStorageFacade2() {
    this.storage = null;
    this.prefix = PREFIX;
  }
  BrowserStorageFacade2.prototype.configure = function(params) {
    Object.assign(this, params);
  };
  BrowserStorageFacade2.prototype.hasKey = function(id) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var _a, _b, _c;
      return tslib_1.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            this.check();
            if (!(this.storage !== null))
              return [3, 2];
            _c = (_b = Object).keys;
            return [4, this.storage.get(this.prefix + ":" + id)];
          case 1:
            _a = !!_c.apply(_b, [_d.sent()]).length;
            return [3, 3];
          case 2:
            _a = null;
            _d.label = 3;
          case 3:
            return [2, _a];
        }
      });
    });
  };
  BrowserStorageFacade2.prototype.getKey = function(id) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var key, itemObj, _a, item;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            this.check();
            key = this.prefix + ":" + id;
            if (!(this.storage !== null))
              return [3, 2];
            return [4, this.storage.get(key)];
          case 1:
            _a = _b.sent();
            return [3, 3];
          case 2:
            _a = null;
            _b.label = 3;
          case 3:
            itemObj = _a;
            item = itemObj[key];
            return [2, item || null];
        }
      });
    });
  };
  BrowserStorageFacade2.prototype.setKey = function(id, key) {
    var _a;
    this.check();
    return this.storage !== null ? this.storage.set((_a = {}, _a[this.prefix + ":" + id] = tslib_1.__assign({}, key), _a)) : null;
  };
  BrowserStorageFacade2.prototype.removeKey = function(id) {
    this.check();
    return this.storage !== null ? this.storage.remove(this.prefix + ":" + id) : null;
  };
  BrowserStorageFacade2.prototype.getAllKeys = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var regexp, keys, storageObj, storageKeys, _i, storageKeys_1, storageKey, raw_id, key;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.check();
            regexp = RegExp("^" + PREFIX + "\\:(.*)");
            keys = [];
            if (!(this.storage !== null))
              return [3, 5];
            return [4, this.storage.get(null)];
          case 1:
            storageObj = _a.sent();
            storageKeys = Object.keys(storageObj);
            _i = 0, storageKeys_1 = storageKeys;
            _a.label = 2;
          case 2:
            if (!(_i < storageKeys_1.length))
              return [3, 5];
            storageKey = storageKeys_1[_i];
            raw_id = storageKey;
            if (!(raw_id !== null && regexp.test(raw_id)))
              return [3, 4];
            return [4, this.getKey(regexp.exec(raw_id)[1])];
          case 3:
            key = _a.sent();
            if (key !== null) {
              keys.push(key);
            }
            _a.label = 4;
          case 4:
            _i++;
            return [3, 2];
          case 5:
            return [2, keys];
        }
      });
    });
  };
  BrowserStorageFacade2.prototype.check = function() {
    if (this.storage === null) {
      throw new Error("A storage object must have been set");
    }
    if (this.prefix === "") {
      throw new Error("A non-empty prefix must have been set");
    }
    return this.storage !== null && this.prefix !== "";
  };
  return BrowserStorageFacade2;
}();
var BrowserStorageKeyStore = function() {
  function BrowserStorageKeyStore2() {
    this.name = "BrowserStorageKeyStore";
    this.keyStore = new BrowserStorageFacade();
  }
  BrowserStorageKeyStore2.prototype.configure = function(params) {
    try {
      this.keyStore.configure(params);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  BrowserStorageKeyStore2.prototype.storeKeys = function(keys) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var usedKeys, _i, keys_1, encryptedKey, hasKey, keysMetadata, _a, keys_2, encryptedKey;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            usedKeys = [];
            _i = 0, keys_1 = keys;
            _b.label = 1;
          case 1:
            if (!(_i < keys_1.length))
              return [3, 4];
            encryptedKey = keys_1[_i];
            return [4, this.keyStore.hasKey(encryptedKey.id)];
          case 2:
            hasKey = _b.sent();
            if (hasKey) {
              usedKeys.push(encryptedKey);
            }
            _b.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            if (usedKeys.length) {
              return [2, Promise.reject("Some keys were already stored in the keystore: " + usedKeys.map(function(k) {
                return k.id;
              }).join(", "))];
            }
            keysMetadata = [];
            for (_a = 0, keys_2 = keys; _a < keys_2.length; _a++) {
              encryptedKey = keys_2[_a];
              this.keyStore.setKey(encryptedKey.id, encryptedKey);
              keysMetadata.push(getKeyMetadata(encryptedKey));
            }
            return [2, Promise.resolve(keysMetadata)];
        }
      });
    });
  };
  BrowserStorageKeyStore2.prototype.updateKeys = function(keys) {
    var _this = this;
    var invalidKeys = keys.filter(function(encryptedKey) {
      return tslib_1.__awaiter(_this, void 0, void 0, function() {
        return tslib_1.__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.keyStore.hasKey(encryptedKey.id)];
            case 1:
              return [2, !_a.sent()];
          }
        });
      });
    });
    if (invalidKeys.length) {
      return Promise.reject("Some keys couldn't be found in the keystore: " + invalidKeys.map(function(k) {
        return k.id;
      }).join(", "));
    }
    var keysMetadata = keys.map(function(encryptedKey) {
      _this.keyStore.setKey(encryptedKey.id, encryptedKey);
      return getKeyMetadata(encryptedKey);
    });
    return Promise.resolve(keysMetadata);
  };
  BrowserStorageKeyStore2.prototype.loadKey = function(id) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var key;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.keyStore.getKey(id)];
          case 1:
            key = _a.sent();
            if (!key) {
              return [2, Promise.reject(id)];
            }
            return [2, Promise.resolve(key)];
        }
      });
    });
  };
  BrowserStorageKeyStore2.prototype.removeKey = function(id) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var key, metadata;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.keyStore.hasKey(id)) {
              return [2, Promise.reject(id)];
            }
            return [4, this.keyStore.getKey(id)];
          case 1:
            key = _a.sent();
            metadata = getKeyMetadata(key);
            this.keyStore.removeKey(id);
            return [2, Promise.resolve(metadata)];
        }
      });
    });
  };
  BrowserStorageKeyStore2.prototype.loadAllKeys = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var keys;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.keyStore.getAllKeys()];
          case 1:
            keys = _a.sent();
            return [2, Promise.resolve(keys)];
        }
      });
    });
  };
  return BrowserStorageKeyStore2;
}();
var NAME$1 = "IdentityEncrypter";
var IdentityEncrypter = {
  name: NAME$1,
  encryptKey: function(params) {
    var key = params.key;
    var type = key.type, privateKey = key.privateKey, publicKey = key.publicKey, path = key.path, extra = key.extra, props = tslib_1.__rest(key, ["type", "privateKey", "publicKey", "path", "extra"]);
    return Promise.resolve(tslib_1.__assign({}, props, { encryptedBlob: JSON.stringify({
      type,
      publicKey,
      privateKey,
      path,
      extra
    }), encrypterName: NAME$1, salt: "identity" }));
  },
  decryptKey: function(params) {
    var encryptedKey = params.encryptedKey;
    var _a = encryptedKey;
    _a.encrypterName;
    _a.salt;
    var encryptedBlob = _a.encryptedBlob, props = tslib_1.__rest(_a, ["encrypterName", "salt", "encryptedBlob"]);
    var data = JSON.parse(encryptedBlob);
    return Promise.resolve(tslib_1.__assign({}, props, data));
  }
};
var LocalStorageFacade = function() {
  function LocalStorageFacade2() {
    this.storage = null;
    this.prefix = "stellarkeys";
  }
  LocalStorageFacade2.prototype.configure = function(params) {
    Object.assign(this, params);
  };
  LocalStorageFacade2.prototype.hasKey = function(id) {
    this.check();
    return this.storage !== null ? this.storage.getItem(this.prefix + ":" + id) !== null : null;
  };
  LocalStorageFacade2.prototype.getKey = function(id) {
    this.check();
    var item = this.storage !== null ? this.storage.getItem(this.prefix + ":" + id) : null;
    return item ? JSON.parse(item) : null;
  };
  LocalStorageFacade2.prototype.setKey = function(id, key) {
    this.check();
    return this.storage !== null ? this.storage.setItem(this.prefix + ":" + id, JSON.stringify(tslib_1.__assign({}, key))) : null;
  };
  LocalStorageFacade2.prototype.removeKey = function(id) {
    this.check();
    return this.storage !== null ? this.storage.removeItem(this.prefix + ":" + id) : null;
  };
  LocalStorageFacade2.prototype.getAllKeys = function() {
    this.check();
    var regexp = RegExp("^" + this.prefix + "\\:(.*)");
    var keys = [];
    if (this.storage !== null) {
      for (var i = 0; i < this.storage.length; i++) {
        var raw_id = this.storage.key(i);
        if (raw_id !== null && regexp.test(raw_id)) {
          var key = this.getKey(regexp.exec(raw_id)[1]);
          if (key !== null) {
            keys.push(key);
          }
        }
      }
    }
    return keys;
  };
  LocalStorageFacade2.prototype.check = function() {
    if (this.storage === null) {
      throw new Error("A storage object must have been set");
    }
    if (this.prefix === "") {
      throw new Error("A non-empty prefix must have been set");
    }
    return this.storage !== null && this.prefix !== "";
  };
  return LocalStorageFacade2;
}();
var LocalStorageKeyStore = function() {
  function LocalStorageKeyStore2() {
    this.name = "LocalStorageKeyStore";
    this.keyStore = new LocalStorageFacade();
  }
  LocalStorageKeyStore2.prototype.configure = function(params) {
    try {
      this.keyStore.configure(params);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  LocalStorageKeyStore2.prototype.storeKeys = function(keys) {
    var _this = this;
    var invalidKeys = keys.filter(function(encryptedKey) {
      return _this.keyStore.hasKey(encryptedKey.id);
    });
    if (invalidKeys.length) {
      return Promise.reject("Some keys were already stored in the keystore: " + invalidKeys.map(function(k) {
        return k.id;
      }).join(", "));
    }
    var keysMetadata = keys.map(function(encryptedKey) {
      _this.keyStore.setKey(encryptedKey.id, encryptedKey);
      return getKeyMetadata(encryptedKey);
    });
    return Promise.resolve(keysMetadata);
  };
  LocalStorageKeyStore2.prototype.updateKeys = function(keys) {
    var _this = this;
    var invalidKeys = keys.filter(function(encryptedKey) {
      return !_this.keyStore.hasKey(encryptedKey.id);
    });
    if (invalidKeys.length) {
      return Promise.reject("Some keys couldn't be found in the keystore: " + invalidKeys.map(function(k) {
        return k.id;
      }).join(", "));
    }
    var keysMetadata = keys.map(function(encryptedKey) {
      _this.keyStore.setKey(encryptedKey.id, encryptedKey);
      return getKeyMetadata(encryptedKey);
    });
    return Promise.resolve(keysMetadata);
  };
  LocalStorageKeyStore2.prototype.loadKey = function(id) {
    var key = this.keyStore.getKey(id);
    if (!key) {
      return Promise.reject(id);
    }
    return Promise.resolve(key);
  };
  LocalStorageKeyStore2.prototype.removeKey = function(id) {
    if (!this.keyStore.hasKey(id)) {
      return Promise.reject(id);
    }
    var metadata = getKeyMetadata(this.keyStore.getKey(id));
    this.keyStore.removeKey(id);
    return Promise.resolve(metadata);
  };
  LocalStorageKeyStore2.prototype.loadAllKeys = function() {
    return Promise.resolve(this.keyStore.getAllKeys());
  };
  return LocalStorageKeyStore2;
}();
var MemoryKeyStore = function() {
  function MemoryKeyStore2() {
    this.name = "MemoryKeyStore";
    this.keyStore = {};
  }
  MemoryKeyStore2.prototype.configure = function() {
    return Promise.resolve();
  };
  MemoryKeyStore2.prototype.storeKeys = function(keys) {
    var _this = this;
    var invalidKeys = keys.filter(function(encryptedKey) {
      return !!_this.keyStore[encryptedKey.id];
    });
    if (invalidKeys.length) {
      return Promise.reject("Some keys were already stored in the keystore: " + invalidKeys.map(function(k) {
        return k.id;
      }).join(", "));
    }
    var keysMetadata = keys.map(function(encryptedKey) {
      _this.keyStore[encryptedKey.id] = tslib_1.__assign({}, encryptedKey);
      return getKeyMetadata(_this.keyStore[encryptedKey.id]);
    });
    return Promise.resolve(keysMetadata);
  };
  MemoryKeyStore2.prototype.updateKeys = function(keys) {
    var _this = this;
    var invalidKeys = keys.filter(function(encryptedKey) {
      return !_this.keyStore[encryptedKey.id];
    });
    if (invalidKeys.length) {
      return Promise.reject("Some keys couldn't be found in the keystore: " + invalidKeys.map(function(k) {
        return k.id;
      }).join(", "));
    }
    var keysMetadata = keys.map(function(encryptedKey) {
      var id = encryptedKey.id;
      _this.keyStore[id] = tslib_1.__assign({}, encryptedKey);
      return getKeyMetadata(_this.keyStore[id]);
    });
    return Promise.resolve(keysMetadata);
  };
  MemoryKeyStore2.prototype.loadKey = function(id) {
    return Promise.resolve(this.keyStore[id]);
  };
  MemoryKeyStore2.prototype.removeKey = function(id) {
    if (!this.keyStore[id]) {
      return Promise.reject(id);
    }
    var metadata = getKeyMetadata(this.keyStore[id]);
    delete this.keyStore[id];
    return Promise.resolve(metadata);
  };
  MemoryKeyStore2.prototype.loadAllKeys = function() {
    return Promise.resolve(Object.values(this.keyStore).map(function(item) {
      return item;
    }));
  };
  return MemoryKeyStore2;
}();
var SALT_BYTES = 32;
var NONCE_BYTES = nacl.secretbox.nonceLength;
nacl.secretbox.keyLength;
var CRYPTO_V1 = 1;
var CURRENT_CRYPTO_VERSION = CRYPTO_V1;
var KEY_LEN = nacl.secretbox.keyLength;
function scryptPass(params) {
  var password = params.password, salt = params.salt, _a = params.dkLen, dkLen = _a === void 0 ? KEY_LEN : _a;
  var _b = [32768, 8, 1], N = _b[0], r = _b[1], p = _b[2];
  return new Promise(function(resolve, reject) {
    scrypt(password, salt, { N, r, p, dkLen, encoding: "binary" }, function(derivedKey) {
      if (derivedKey) {
        resolve(derivedKey);
      } else {
        reject(new Error("scryptPass failed, derivedKey is null"));
      }
    });
  });
}
function generateSalt() {
  return naclutil.encodeBase64(nacl.randomBytes(SALT_BYTES));
}
function encrypt(params) {
  return tslib_1.__awaiter(this, void 0, void 0, function() {
    var phrase, password, salt, nonce, secretboxSalt, secretboxNonce, scryptedPass, textBytes, cipherText, bundle;
    return tslib_1.__generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          phrase = params.phrase, password = params.password, salt = params.salt, nonce = params.nonce;
          secretboxSalt = salt || generateSalt();
          secretboxNonce = nonce || nacl.randomBytes(NONCE_BYTES);
          return [4, scryptPass({ password, salt: secretboxSalt })];
        case 1:
          scryptedPass = _a.sent();
          textBytes = naclutil.decodeUTF8(phrase);
          cipherText = nacl.secretbox(textBytes, secretboxNonce, scryptedPass);
          if (!cipherText) {
            throw new Error("Encryption failed");
          }
          bundle = new Uint8Array(1 + secretboxNonce.length + cipherText.length);
          bundle.set([CURRENT_CRYPTO_VERSION]);
          bundle.set(secretboxNonce, 1);
          bundle.set(cipherText, 1 + secretboxNonce.length);
          return [2, {
            encryptedPhrase: naclutil.encodeBase64(bundle),
            salt: secretboxSalt
          }];
      }
    });
  });
}
function decrypt(params) {
  return tslib_1.__awaiter(this, void 0, void 0, function() {
    var phrase, password, salt, scryptedPass, bundle, version2, decryptedBytes, nonce, cipherText;
    return tslib_1.__generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          phrase = params.phrase, password = params.password, salt = params.salt;
          return [4, scryptPass({ password, salt })];
        case 1:
          scryptedPass = _a.sent();
          bundle = naclutil.decodeBase64(phrase);
          version2 = bundle[0];
          if (version2 === CRYPTO_V1) {
            nonce = bundle.slice(1, 1 + NONCE_BYTES);
            cipherText = bundle.slice(1 + NONCE_BYTES);
            decryptedBytes = nacl.secretbox.open(cipherText, nonce, scryptedPass);
          } else {
            throw new Error("Cipher version " + version2 + " not supported.");
          }
          if (!decryptedBytes) {
            throw new Error("That passphrase wasn’t valid.");
          }
          return [2, naclutil.encodeUTF8(decryptedBytes)];
      }
    });
  });
}
var NAME = "ScryptEncrypter";
var ScryptEncrypter = {
  name: NAME,
  encryptKey: function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var key, password, privateKey, path, extra, publicKey, type, props, _a, encryptedPhrase, salt;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            key = params.key, password = params.password;
            privateKey = key.privateKey, path = key.path, extra = key.extra, publicKey = key.publicKey, type = key.type, props = tslib_1.__rest(key, ["privateKey", "path", "extra", "publicKey", "type"]);
            return [4, encrypt({
              password,
              phrase: JSON.stringify({ privateKey, path, extra, publicKey, type })
            })];
          case 1:
            _a = _b.sent(), encryptedPhrase = _a.encryptedPhrase, salt = _a.salt;
            return [2, tslib_1.__assign({}, props, { encryptedBlob: encryptedPhrase, encrypterName: NAME, salt })];
        }
      });
    });
  },
  decryptKey: function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var encryptedKey, password, salt, encryptedBlob, props, data, _a, _b;
      return tslib_1.__generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            encryptedKey = params.encryptedKey, password = params.password;
            encryptedKey.encrypterName, salt = encryptedKey.salt, encryptedBlob = encryptedKey.encryptedBlob, props = tslib_1.__rest(encryptedKey, ["encrypterName", "salt", "encryptedBlob"]);
            _b = (_a = JSON).parse;
            return [4, decrypt({ phrase: encryptedBlob, salt, password })];
          case 1:
            data = _b.apply(_a, [_c.sent()]);
            return [2, tslib_1.__assign({}, props, data)];
        }
      });
    });
  }
};
var KeyManagerPlugins = {
  BrowserStorageKeyStore,
  IdentityEncrypter,
  MemoryKeyStore,
  LocalStorageKeyStore,
  ScryptEncrypter
};
function getKycUrl(params) {
  var _a = new URL(params.response.url), origin = _a.origin, pathname = _a.pathname, search = _a.search, hash = _a.hash;
  var callback = "";
  var _b = params, callback_url = _b.callback_url, request = _b.request;
  if (callback_url === "postMessage") {
    callback = (search ? "&" : "?") + "callback=postMessage";
  } else if (callback_url && request) {
    var url = new URL(callback_url);
    var newParams = tslib_1.__assign({}, queryString.parse(url.search));
    newParams.request = encodeURIComponent(JSON.stringify(request));
    url.search = queryString.stringify(newParams);
    callback = (search ? "&" : "?") + "callback=" + encodeURIComponent(url.toString());
  }
  return "" + origin + pathname + search + callback + hash;
}
function fetchKycInBrowser(params) {
  var response = params.response, windowContext = params.window;
  var origin = new URL(response.url).origin;
  return new Promise(function(resolve, reject) {
    var handleMessage = function(e) {
      if (e.origin !== origin) {
        return;
      }
      windowContext.removeEventListener("message", handleMessage);
      windowContext.close();
      if (e.data.status === "success") {
        resolve(e.data);
      } else {
        reject(e.data);
      }
    };
    windowContext.addEventListener("message", handleMessage);
    windowContext.location.href = getKycUrl({
      response,
      callback_url: "postMessage"
    });
  });
}
function isValidInfoResponse(obj) {
  return obj.withdraw !== void 0 && obj.deposit !== void 0;
}
function parseInfo(info) {
  if (!isValidInfoResponse(info)) {
    throw new Error("The endpoint didn't return a valid info response!");
  }
  var _a = info, fee = _a.fee, transactions = _a.transactions, transaction = _a.transaction;
  return {
    withdraw: parseWithdraw(info),
    deposit: parseDeposit(info),
    fee,
    transactions,
    transaction
  };
}
var parseFee = function(_a, feeEnabled) {
  var fee_fixed = _a.fee_fixed, fee_percent = _a.fee_percent;
  if (fee_fixed !== void 0 && Number(fee_fixed) >= 0 || fee_percent !== void 0 && Number(fee_percent) >= 0) {
    return {
      type: "simple",
      fixed: fee_fixed,
      percent: fee_percent
    };
  } else {
    return {
      type: feeEnabled ? "complex" : "none"
    };
  }
};
function parseType(_a) {
  var typeName = _a[0], type = _a[1];
  return {
    name: typeName,
    fields: Object.entries(type.fields || {}).map(parseField)
  };
}
function parseField(_a) {
  var fieldName = _a[0], field = _a[1];
  return tslib_1.__assign({}, field, { name: fieldName });
}
function parseWithdraw(info) {
  return Object.entries(info.withdraw).reduce(function(accum, _a) {
    var asset_code = _a[0], entry = _a[1];
    var fee = parseFee(entry, !!(info.fee && info.fee.enabled));
    accum[asset_code] = {
      asset_code,
      fee,
      min_amount: entry.min_amount,
      max_amount: entry.max_amount,
      authentication_required: !!entry.authentication_required,
      types: Object.entries(entry.types || {}).map(parseType)
    };
    return accum;
  }, {});
}
function parseDeposit(info) {
  return Object.entries(info.deposit).reduce(function(accum, _a) {
    var asset_code = _a[0], entry = _a[1];
    var fee = parseFee(entry, !!(info.fee && info.fee.enabled));
    accum[asset_code] = {
      asset_code,
      fee,
      min_amount: entry.min_amount,
      max_amount: entry.max_amount,
      authentication_required: !!entry.authentication_required,
      fields: Object.entries(entry.fields || {}).map(parseField)
    };
    return accum;
  }, {});
}
function _normalizeTransaction(transaction) {
  if (transaction._id && transaction.id === void 0) {
    transaction.id = transaction._id;
  }
  if (transaction.amount && transaction.amount_in === void 0 && transaction.amount_out === void 0) {
    transaction.amount_in = transaction.amount;
    transaction.amount_out = transaction.amount;
  }
  return transaction;
}
var TransferProvider = function() {
  function TransferProvider2(transferServer, account, lang, operation) {
    if (!transferServer) {
      throw new Error("Required parameter `transferServer` missing!");
    }
    if (!account) {
      throw new Error("Required parameter `account` missing!");
    }
    if (!operation) {
      throw new Error("Required parameter `operation` missing!");
    }
    this.transferServer = transferServer.replace(/\/$/, "");
    this.operation = operation;
    this.account = account;
    this.lang = lang;
    this._watchOneTransactionRegistry = {};
    this._watchAllTransactionsRegistry = {};
    this._transactionsRegistry = {};
    this._transactionsIgnoredRegistry = {};
    this._oneTransactionWatcher = {};
  }
  TransferProvider2.prototype.fetchInfo = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var response, badResponse, _a, error2, message, text, rawInfo, info;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, fetch(this.transferServer + "/info?lang=" + this.lang)];
          case 1:
            response = _b.sent();
            if (!!response.ok)
              return [3, 3];
            return [4, response.text()];
          case 2:
            badResponse = _b.sent();
            try {
              _a = JSON.parse(badResponse), error2 = _a.error, message = _a.message;
              throw new Error("Error fetching info from " + this.transferServer + ": error " + (error2 || message));
            } catch (e) {
              throw new Error("Error fetching info from " + this.transferServer + ": error \n          code " + response.status + ', response text: "' + badResponse + '"');
            }
            _b.label = 3;
          case 3:
            return [4, response.text()];
          case 4:
            text = _b.sent();
            try {
              rawInfo = JSON.parse(text);
              info = parseInfo(rawInfo);
              this.info = info;
              return [2, info];
            } catch (e) {
              throw new Error("Error parsing the response of " + this.transferServer + "/info as JSON: " + text);
            }
            return [2];
        }
      });
    });
  };
  TransferProvider2.prototype.getHeaders = function(headers) {
    if (headers === void 0) {
      headers = {};
    }
    if (headers.Authorization && this.authToken) {
      throw new Error("You passed an `Authorization` header that will get wiped out by SEP-10 auth");
    }
    return new Headers(this.authToken ? tslib_1.__assign({}, headers, { Authorization: "Bearer " + this.authToken }) : headers);
  };
  TransferProvider2.prototype.setAuthToken = function(token) {
    this.authToken = token;
  };
  TransferProvider2.prototype.fetchTransactions = function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var isAuthRequired, kind, response, badResponse, _a, error2, message, text, transactions;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            isAuthRequired = this.getAuthStatus("fetchTransactions", params.asset_code);
            if (!params.show_all_transactions) {
              kind = params.kind || (this.operation === "deposit" ? "deposit" : "withdrawal");
            }
            return [4, fetch(this.transferServer + "/transactions?" + queryString.stringify(tslib_1.__assign({}, params, { kind })), {
              headers: isAuthRequired ? this.getHeaders() : void 0
            })];
          case 1:
            response = _b.sent();
            if (!!response.ok)
              return [3, 3];
            return [4, response.text()];
          case 2:
            badResponse = _b.sent();
            try {
              _a = JSON.parse(badResponse), error2 = _a.error, message = _a.message;
              throw new Error("Error fetching transactions from " + this.transferServer + ": error " + (error2 || message));
            } catch (e) {
              throw new Error("Error fetching transactions from " + this.transferServer + ": error \n          code " + response.status + ', response text: "' + badResponse + '"');
            }
            _b.label = 3;
          case 3:
            return [4, response.text()];
          case 4:
            text = _b.sent();
            try {
              transactions = JSON.parse(text).transactions;
              return [2, transactions.map(_normalizeTransaction)];
            } catch (e) {
              throw new Error("Invalid transaction response from " + this.transferServer + ": " + text);
            }
            return [2];
        }
      });
    });
  };
  TransferProvider2.prototype.fetchTransaction = function(params, isWatching) {
    if (isWatching === void 0) {
      isWatching = false;
    }
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var asset_code, id, stellar_transaction_id, external_transaction_id, lang, isAuthRequired, qs, response, badResponse, _a, error2, message, text, transaction;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            asset_code = params.asset_code, id = params.id, stellar_transaction_id = params.stellar_transaction_id, external_transaction_id = params.external_transaction_id, lang = params.lang;
            if (id === void 0 && stellar_transaction_id === void 0 && external_transaction_id === void 0) {
              throw new Error("fetchTransaction: One of `id`, `external_transaction_id`, or `stellar_transaction_id` must be provided! ");
            }
            isAuthRequired = this.getAuthStatus(isWatching ? "watchOneTransaction" : "fetchTransaction", asset_code);
            qs = {};
            if (id) {
              qs = { id };
            } else if (stellar_transaction_id) {
              qs = { stellar_transaction_id };
            } else if (external_transaction_id) {
              qs = { external_transaction_id };
            }
            if (lang) {
              qs = tslib_1.__assign({ lang }, qs);
            }
            return [4, fetch(this.transferServer + "/transaction?" + queryString.stringify(qs), {
              headers: isAuthRequired ? this.getHeaders() : void 0
            })];
          case 1:
            response = _b.sent();
            if (!!response.ok)
              return [3, 3];
            return [4, response.text()];
          case 2:
            badResponse = _b.sent();
            try {
              _a = JSON.parse(badResponse), error2 = _a.error, message = _a.message;
              throw new Error("Error fetching transaction " + qs + " from " + this.transferServer + ": error " + (error2 || message));
            } catch (e) {
              throw new Error("Error fetching transaction " + qs + " from " + this.transferServer + ": error \n          code " + response.status + ', response text: "' + badResponse + '"');
            }
            _b.label = 3;
          case 3:
            return [4, response.text()];
          case 4:
            text = _b.sent();
            try {
              transaction = JSON.parse(text).transaction;
              return [2, _normalizeTransaction(transaction)];
            } catch (e) {
              throw new Error("Fetch transaction response wasn't valid JSON: " + text);
            }
            return [2];
        }
      });
    });
  };
  TransferProvider2.prototype.watchAllTransactions = function(params) {
    var _this = this;
    var _a;
    var asset_code = params.asset_code, onMessage = params.onMessage, onError = params.onError, _b = params.watchlist, watchlist = _b === void 0 ? [] : _b, _c = params.timeout, timeout = _c === void 0 ? 5e3 : _c, _d = params.isRetry, isRetry = _d === void 0 ? false : _d, otherParams = tslib_1.__rest(params, ["asset_code", "onMessage", "onError", "watchlist", "timeout", "isRetry"]);
    var watchlistMap = watchlist.reduce(function(memo, id) {
      var _a2;
      return tslib_1.__assign({}, memo, (_a2 = {}, _a2[id] = true, _a2));
    }, {});
    if (!isRetry) {
      this._watchAllTransactionsRegistry = tslib_1.__assign({}, this._watchAllTransactionsRegistry, (_a = {}, _a[asset_code] = true, _a));
    }
    this.fetchTransactions(tslib_1.__assign({ asset_code }, otherParams || {})).then(function(transactions) {
      if (!_this._watchAllTransactionsRegistry[asset_code]) {
        return;
      }
      try {
        var newTransactions = transactions.filter(function(transaction) {
          var isPending = transaction.status.indexOf("pending") === 0 || transaction.status === TransactionStatus.incomplete;
          var registeredTransaction = _this._transactionsRegistry[asset_code][transaction.id];
          if (!isRetry) {
            if (watchlistMap[transaction.id]) {
              return true;
            }
            if (!isPending) {
              _this._transactionsIgnoredRegistry[asset_code][transaction.id] = transaction;
            }
            return isPending;
          }
          if (registeredTransaction) {
            return !isEqual(registeredTransaction, transaction);
          }
          if ([
            TransactionStatus.completed,
            TransactionStatus.refunded,
            TransactionStatus.error
          ].includes(transaction.status) && isRetry && !_this._transactionsIgnoredRegistry[asset_code][transaction.id]) {
            return true;
          }
          if (isPending) {
            return true;
          }
          return false;
        });
        newTransactions.forEach(function(transaction) {
          _this._transactionsRegistry[asset_code][transaction.id] = transaction;
          if (transaction.status === TransactionStatus.error) {
            onError(transaction);
          } else {
            onMessage(transaction);
          }
        });
      } catch (e) {
        onError(e);
        return;
      }
      if (_this._allTransactionsWatcher) {
        clearTimeout(_this._allTransactionsWatcher);
      }
      _this._allTransactionsWatcher = setTimeout(function() {
        _this.watchAllTransactions(tslib_1.__assign({
          asset_code,
          onMessage,
          onError,
          timeout,
          isRetry: true
        }, otherParams || {}));
      }, timeout);
    }).catch(function(e) {
      onError(e);
    });
    return {
      refresh: function() {
        if (!_this._watchAllTransactionsRegistry[asset_code]) {
          return;
        }
        if (_this._allTransactionsWatcher) {
          clearTimeout(_this._allTransactionsWatcher);
        }
        _this.watchAllTransactions(tslib_1.__assign({
          asset_code,
          onMessage,
          onError,
          timeout,
          isRetry: true
        }, otherParams || {}));
      },
      stop: function() {
        if (_this._allTransactionsWatcher) {
          _this._watchAllTransactionsRegistry[asset_code] = false;
          _this._transactionsRegistry[asset_code] = {};
          _this._transactionsIgnoredRegistry[asset_code] = {};
          clearTimeout(_this._allTransactionsWatcher);
        }
      }
    };
  };
  TransferProvider2.prototype.watchOneTransaction = function(params) {
    var _this = this;
    var _a, _b;
    var asset_code = params.asset_code, id = params.id, external_transaction_id = params.external_transaction_id, stellar_transaction_id = params.stellar_transaction_id, onMessage = params.onMessage, onSuccess = params.onSuccess, onError = params.onError, _c = params.timeout, timeout = _c === void 0 ? 5e3 : _c, _d = params.isRetry, isRetry = _d === void 0 ? false : _d, otherParams = tslib_1.__rest(params, ["asset_code", "id", "external_transaction_id", "stellar_transaction_id", "onMessage", "onSuccess", "onError", "timeout", "isRetry"]);
    var txId = id || external_transaction_id || stellar_transaction_id;
    if (txId === void 0) {
      throw new Error("fetchTransaction: One of `id`, `external_transaction_id`, or `stellar_transaction_id` must be provided! ");
    }
    if (!isRetry) {
      this._watchOneTransactionRegistry = tslib_1.__assign({}, this._watchOneTransactionRegistry, (_a = {}, _a[asset_code] = tslib_1.__assign({}, this._watchOneTransactionRegistry[asset_code] || {}, (_b = {}, _b[txId] = true, _b)), _a));
    }
    this.fetchTransaction(tslib_1.__assign({ asset_code, id }, otherParams || {}), true).then(function(transaction) {
      if (!(_this._watchOneTransactionRegistry[asset_code] && _this._watchOneTransactionRegistry[asset_code][txId])) {
        return;
      }
      var registeredTransaction = _this._transactionsRegistry[asset_code][transaction.id];
      if (registeredTransaction && isEqual(registeredTransaction, transaction)) {
        return;
      }
      _this._transactionsRegistry[asset_code][transaction.id] = transaction;
      if (transaction.status.indexOf("pending") === 0) {
        if (_this._oneTransactionWatcher[txId]) {
          clearTimeout(_this._oneTransactionWatcher[txId]);
        }
        _this._oneTransactionWatcher[txId] = setTimeout(function() {
          _this.watchOneTransaction(tslib_1.__assign({
            asset_code,
            id,
            external_transaction_id,
            stellar_transaction_id,
            onMessage,
            onSuccess,
            onError,
            timeout,
            isRetry: true
          }, otherParams || {}));
        }, timeout);
        onMessage(transaction);
      } else if ([TransactionStatus.completed, TransactionStatus.refunded].includes(transaction.status)) {
        onSuccess(transaction);
      } else {
        onError(transaction);
      }
    }).catch(function(e) {
      onError(e);
    });
    return {
      refresh: function() {
        if (!(_this._watchOneTransactionRegistry[asset_code] && _this._watchOneTransactionRegistry[asset_code][txId])) {
          return;
        }
        if (_this._oneTransactionWatcher[txId]) {
          clearTimeout(_this._oneTransactionWatcher[txId]);
        }
        _this.watchOneTransaction(tslib_1.__assign({
          asset_code,
          id,
          external_transaction_id,
          stellar_transaction_id,
          onMessage,
          onSuccess,
          onError,
          timeout,
          isRetry: true
        }, otherParams || {}));
      },
      stop: function() {
        if (_this._oneTransactionWatcher[txId]) {
          _this._watchOneTransactionRegistry[asset_code][txId] = false;
          clearTimeout(_this._oneTransactionWatcher[txId]);
        }
      }
    };
  };
  TransferProvider2.prototype.fetchFinalFee = function(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var assetInfo, fee, _a, simpleFee, response, badResponse, _b, error2, message, text, feeResponse;
      return tslib_1.__generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            if (!this.info || !this.info[this.operation]) {
              throw new Error("Run fetchSupportedAssets before running fetchFinalFee!");
            }
            assetInfo = this.info[this.operation][params.asset_code];
            if (!assetInfo) {
              throw new Error("Can't get fee for an unsupported asset, '" + params.asset_code);
            }
            fee = assetInfo.fee;
            _a = fee.type;
            switch (_a) {
              case "none":
                return [3, 1];
              case "simple":
                return [3, 2];
              case "complex":
                return [3, 3];
            }
            return [3, 8];
          case 1:
            return [2, 0];
          case 2:
            simpleFee = fee;
            return [2, (simpleFee.percent || 0) / 100 * Number(params.amount) + (simpleFee.fixed || 0)];
          case 3:
            return [4, fetch(this.transferServer + "/fee?" + queryString.stringify(tslib_1.__assign({}, params, fee, { operation: this.operation })))];
          case 4:
            response = _c.sent();
            if (!!response.ok)
              return [3, 6];
            return [4, response.text()];
          case 5:
            badResponse = _c.sent();
            try {
              _b = JSON.parse(badResponse), error2 = _b.error, message = _b.message;
              throw new Error("Error fetching fees from " + this.transferServer + ": error " + (error2 || message));
            } catch (e) {
              throw new Error("Error fetching fees from " + this.transferServer + ": error \n              code " + response.status + ', response text: "' + badResponse + '"');
            }
            _c.label = 6;
          case 6:
            return [4, response.text()];
          case 7:
            text = _c.sent();
            try {
              feeResponse = JSON.parse(text).fee;
              return [2, feeResponse];
            } catch (e) {
              throw new Error("Fee endpoint returned invalid JSON: " + text);
            }
            _c.label = 8;
          case 8:
            throw new Error("Invalid fee type found! Got '" + fee.type + "' but expected one of 'none', 'simple', 'complex'");
        }
      });
    });
  };
  TransferProvider2.prototype.getAuthStatus = function(functionName, asset_code) {
    if (!asset_code) {
      throw new Error("Required parameter `asset_code` not provided!");
    }
    if (!this.info || !this.info[this.operation]) {
      throw new Error("Run fetchSupportedAssets before running " + functionName + "!");
    }
    var assetInfo = this.info[this.operation][asset_code];
    if (!assetInfo) {
      throw new Error("Asset " + asset_code + " is not supported by " + this.transferServer);
    }
    if (!this.authToken) {
      throw new Error("\n        Asset " + asset_code + " requires authentication. Run KeyManager's \n        fetchAuthToken function, then run setAuthToken to set it.\n        ");
    }
    return true;
  };
  return TransferProvider2;
}();
var emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
function validateEmail(email) {
  return !!email.match(emailRegex);
}
(function(_super) {
  tslib_1.__extends(DepositProvider, _super);
  function DepositProvider(transferServer, account, lang) {
    if (lang === void 0) {
      lang = "en";
    }
    return _super.call(this, transferServer, account, lang, "deposit") || this;
  }
  DepositProvider.prototype.startDeposit = function(params, shouldUseNewEndpoints, headers) {
    if (shouldUseNewEndpoints === void 0) {
      shouldUseNewEndpoints = false;
    }
    if (headers === void 0) {
      headers = {};
    }
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var request, isAuthRequired, response, json, body_1, qs, isAnchorUSDSep6, responseText, error2, text, error2, _a, origin_1, pathname, search, hash;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            request = tslib_1.__assign({}, params, { account: this.account, lang: this.lang });
            isAuthRequired = this.getAuthStatus("deposit", params.asset_code);
            if (!shouldUseNewEndpoints)
              return [3, 2];
            body_1 = new FormData();
            Object.keys(request).forEach(function(key) {
              body_1.append(key, request[key]);
            });
            return [4, fetch(this.transferServer + "/transactions/deposit/interactive", {
              method: "POST",
              body: body_1,
              headers: isAuthRequired ? this.getHeaders(headers) : void 0
            })];
          case 1:
            response = _b.sent();
            return [3, 4];
          case 2:
            qs = queryString.stringify(request);
            return [4, fetch(this.transferServer + "/deposit?" + qs, {
              headers: isAuthRequired ? this.getHeaders(headers) : void 0
            })];
          case 3:
            response = _b.sent();
            _b.label = 4;
          case 4:
            isAnchorUSDSep6 = !shouldUseNewEndpoints && this.transferServer.includes("anchorusd.com");
            if (!(!response.ok && !isAnchorUSDSep6))
              return [3, 6];
            return [4, response.text()];
          case 5:
            responseText = _b.sent();
            try {
              error2 = JSON.parse(responseText).error;
              throw new Error("Error starting deposit to " + this.transferServer + ": error " + error2);
            } catch (e) {
              throw new Error("Error starting deposit to " + this.transferServer + ": error \n          code " + response.status + ', status text: "' + responseText + '"');
            }
            _b.label = 6;
          case 6:
            return [4, response.text()];
          case 7:
            text = _b.sent();
            try {
              json = JSON.parse(text);
            } catch (e) {
              throw new Error("Error parsing the deposit response as JSON: " + text);
            }
            if (json.error) {
              error2 = new Error(typeof json.error === "string" ? json.error : JSON.stringify(json.error));
              error2.originalResponse = json;
              throw error2;
            }
            if (isAuthRequired && json.type === TransferResponseType.interactive_customer_info_needed && json.url && json.url.indexOf("jwt") === -1) {
              _a = new URL(json.url), origin_1 = _a.origin, pathname = _a.pathname, search = _a.search, hash = _a.hash;
              json.url = "" + origin_1 + pathname + search + (search ? "&" : "?") + "jwt=" + this.authToken + hash;
            }
            this.request = request;
            this.response = json;
            return [2, json];
        }
      });
    });
  };
  DepositProvider.prototype.fetchSupportedAssets = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var deposit;
      var _this = this;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.fetchInfo()];
          case 1:
            deposit = _a.sent().deposit;
            Object.keys(deposit).forEach(function(code) {
              _this._watchOneTransactionRegistry[code] = _this._watchOneTransactionRegistry[code] || {};
              _this._watchAllTransactionsRegistry[code] = false;
              _this._transactionsRegistry[code] = _this._transactionsRegistry[code] || {};
              _this._transactionsIgnoredRegistry[code] = _this._transactionsIgnoredRegistry[code] || {};
            });
            return [2, deposit];
        }
      });
    });
  };
  DepositProvider.prototype.getAssetInfo = function(asset_code) {
    if (!this.info || !this.info[this.operation]) {
      throw new Error("Run fetchSupportedAssets before running getAssetInfo!");
    }
    if (!this.info[this.operation][asset_code]) {
      throw new Error("Asset not supported: " + asset_code);
    }
    return this.info[this.operation][asset_code];
  };
  DepositProvider.prototype.fetchKycInBrowser = function(windowContext) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var kycResult;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.response || !this.request) {
              throw new Error("Run startDeposit before calling fetchKycInBrowser!");
            }
            if (this.response.type !== TransferResponseType.interactive_customer_info_needed || !this.response.url) {
              throw new Error("KYC not needed for this deposit!");
            }
            return [4, fetchKycInBrowser({
              response: this.response,
              request: this.request,
              window: windowContext
            })];
          case 1:
            kycResult = _a.sent();
            if (kycResult.type === TransferResponseType.customer_info_status) {
              switch (kycResult.status) {
                case "denied":
                  return [2, Promise.reject(kycResult)];
                case "pending":
                  return [2, Promise.reject(kycResult)];
                case "success":
                  return [2, Promise.resolve(kycResult)];
                default:
                  throw new Error("Invalid KYC response received: '" + kycResult.status + "'.");
              }
            }
            if (kycResult.status === TransactionStatus.completed) {
              return [2, Promise.resolve(kycResult)];
            }
            return [2, Promise.reject(kycResult)];
        }
      });
    });
  };
  DepositProvider.prototype.getKycUrl = function(callback_url) {
    if (!this.response || !this.request) {
      throw new Error("Run startDeposit before calling getKycUrl!");
    }
    if (this.response.type !== TransferResponseType.interactive_customer_info_needed || !this.response.url) {
      throw new Error("KYC not needed for this deposit!");
    }
    return getKycUrl({
      response: this.response,
      request: this.request,
      callback_url
    });
  };
  DepositProvider.prototype.validateFields = function(asset_code, payload) {
    if (!this.info || !this.info[this.operation]) {
      throw new Error("Run fetchSupportedAssets before running fetchFinalFee!");
    }
    var assetInfo = this.info[this.operation][asset_code];
    if (!assetInfo) {
      throw new Error("Can't get fee for an unsupported asset, '" + asset_code);
    }
    var fields = assetInfo.fields || [];
    return fields.reduce(function(isValid, field) {
      if (!isValid) {
        return isValid;
      }
      if (field.optional) {
        return isValid;
      }
      var response = payload[field.name];
      if (!response) {
        return false;
      }
      if (field.choices) {
        var choiceMap = field.choices.reduce(function(memo, choice) {
          var _a;
          return tslib_1.__assign({}, memo, (_a = {}, _a[choice] = true, _a));
        }, {});
        if (!choiceMap[response]) {
          return false;
        }
      }
      if (field.name === "email" || field.name === "email_address" && !validateEmail(response)) {
        return false;
      }
      if (field.name === "amount" && isNaN(parseFloat(response))) {
        return false;
      }
      return isValid;
    }, true);
  };
  return DepositProvider;
})(TransferProvider);
(function(_super) {
  tslib_1.__extends(WithdrawProvider, _super);
  function WithdrawProvider(transferServer, account, lang) {
    if (lang === void 0) {
      lang = "en";
    }
    return _super.call(this, transferServer, account, lang, "withdraw") || this;
  }
  WithdrawProvider.prototype.startWithdraw = function(params, shouldUseNewEndpoints, headers) {
    if (shouldUseNewEndpoints === void 0) {
      shouldUseNewEndpoints = false;
    }
    if (headers === void 0) {
      headers = {};
    }
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var request, isAuthRequired, response, json, body_1, qs, isAnchorUSDSep6, responseText, error2, text, error2, _a, origin_1, pathname, search, hash;
      return tslib_1.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            request = tslib_1.__assign({}, params, { account: this.account, lang: this.lang });
            isAuthRequired = this.getAuthStatus("withdraw", params.asset_code);
            if (!shouldUseNewEndpoints)
              return [3, 2];
            body_1 = new FormData();
            Object.keys(request).forEach(function(key) {
              body_1.append(key, request[key]);
            });
            return [4, fetch(this.transferServer + "/transactions/withdraw/interactive", {
              method: "POST",
              body: body_1,
              headers: isAuthRequired ? this.getHeaders(headers) : void 0
            })];
          case 1:
            response = _b.sent();
            return [3, 4];
          case 2:
            qs = queryString.stringify(request);
            return [4, fetch(this.transferServer + "/withdraw?" + qs, {
              headers: isAuthRequired ? this.getHeaders(headers) : void 0
            })];
          case 3:
            response = _b.sent();
            _b.label = 4;
          case 4:
            isAnchorUSDSep6 = !shouldUseNewEndpoints && this.transferServer.includes("anchorusd.com");
            if (!(!response.ok && !isAnchorUSDSep6))
              return [3, 6];
            return [4, response.text()];
          case 5:
            responseText = _b.sent();
            try {
              error2 = JSON.parse(responseText).error;
              throw new Error("Error starting withdrawal to " + this.transferServer + ": error " + error2);
            } catch (e) {
              throw new Error("Error starting withdrawal to " + this.transferServer + ": error \n          code " + response.status + ', status text: "' + responseText + '"');
            }
            _b.label = 6;
          case 6:
            return [4, response.text()];
          case 7:
            text = _b.sent();
            try {
              json = JSON.parse(text);
            } catch (e) {
              throw new Error("Error parsing the deposit response as JSON: " + text);
            }
            if (json.error) {
              error2 = new Error(json.error);
              error2.originalResponse = json;
              throw error2;
            }
            if (isAuthRequired && json.type === TransferResponseType.interactive_customer_info_needed && json.url && json.url.indexOf("jwt") === -1) {
              _a = new URL(json.url), origin_1 = _a.origin, pathname = _a.pathname, search = _a.search, hash = _a.hash;
              json.url = "" + origin_1 + pathname + search + (search ? "&" : "?") + "jwt=" + this.authToken + hash;
            }
            this.request = request;
            this.response = json;
            return [2, json];
        }
      });
    });
  };
  WithdrawProvider.prototype.fetchSupportedAssets = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var withdraw;
      var _this = this;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.fetchInfo()];
          case 1:
            withdraw = _a.sent().withdraw;
            Object.keys(withdraw).forEach(function(code) {
              _this._watchOneTransactionRegistry[code] = _this._watchOneTransactionRegistry[code] || {};
              _this._watchAllTransactionsRegistry[code] = false;
              _this._transactionsRegistry[code] = _this._transactionsRegistry[code] || {};
              _this._transactionsIgnoredRegistry[code] = _this._transactionsIgnoredRegistry[code] || {};
            });
            return [2, withdraw];
        }
      });
    });
  };
  WithdrawProvider.prototype.getAssetInfo = function(asset_code) {
    if (!this.info || !this.info[this.operation]) {
      throw new Error("Run fetchSupportedAssets before running getAssetInfo!");
    }
    if (!this.info[this.operation][asset_code]) {
      throw new Error("Asset not supported: " + asset_code);
    }
    return this.info[this.operation][asset_code];
  };
  WithdrawProvider.prototype.fetchKycInBrowser = function(windowContext) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var kycResult;
      return tslib_1.__generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.response || !this.request) {
              throw new Error("Run startWithdraw before calling fetchKycInBrowser!");
            }
            if (this.response.type !== TransferResponseType.interactive_customer_info_needed || !this.response.url) {
              throw new Error("KYC not needed for this withdrawal!");
            }
            return [4, fetchKycInBrowser({
              response: this.response,
              request: this.request,
              window: windowContext
            })];
          case 1:
            kycResult = _a.sent();
            if (kycResult.type === TransferResponseType.customer_info_status) {
              switch (kycResult.status) {
                case "denied":
                  return [2, Promise.reject(kycResult)];
                case "pending":
                  return [2, Promise.reject(kycResult)];
                case "success":
                  return [2, Promise.resolve(kycResult)];
                default:
                  throw new Error("Invalid KYC response received: '" + kycResult.status + "'.");
              }
            }
            if (kycResult.status === TransactionStatus.completed) {
              return [2, Promise.resolve(kycResult)];
            }
            return [2, Promise.reject(kycResult)];
        }
      });
    });
  };
  WithdrawProvider.prototype.getKycUrl = function(callback_url) {
    if (!this.response || !this.request) {
      throw new Error("Run startWithdraw before calling getKycUrl!");
    }
    if (this.response.type !== TransferResponseType.interactive_customer_info_needed || !this.response.url) {
      throw new Error("KYC not needed for this withdrawal!");
    }
    return getKycUrl({
      response: this.response,
      request: this.request,
      callback_url
    });
  };
  return WithdrawProvider;
})(TransferProvider);
function createWalletStore() {
  const { subscribe, set } = persisted("bpa:walletStore", { keyId: "", publicKey: "" });
  return {
    subscribe,
    /**
     * Registers a user by storing their encrypted keypair in the browser's localStorage.
     * @param {Object} opts Options object
     * @param {string} opts.publicKey Public Stellar address which will be the user's public key throughout the application
     * @param {string} opts.secretKey Secret key that corresponds to the user's public key
     * @param {string} opts.pincode Pincode that will be used to encrypt this keypair
     * @throws Will throw an error if there is a problem encrypting and/or storing the keypair
     */
    register: async ({ publicKey, secretKey, pincode }) => {
      try {
        const keyManager = setupKeyManager();
        let keyMetadata = await keyManager.storeKey({
          key: {
            type: KeyType.plaintextKey,
            publicKey,
            privateKey: secretKey
          },
          password: pincode,
          encrypterName: KeyManagerPlugins.ScryptEncrypter.name
        });
        set({
          keyId: keyMetadata.id,
          publicKey,
          // Don't include this in a real-life production application.
          // It's just here to make the secret key accessible in case
          // we need to do some manual transactions or something.
          devInfo: {
            secretKey
          }
        });
      } catch (err) {
        console.error("Error saving key", err);
        throw error(400, { message: err.toString() });
      }
    },
    /**
     * Compares a submitted pincode to make sure it is valid for the stored, encrypted keypair.
     * @param {Object} opts Options object
     * @param {string} opts.pincode Pincode being confirmed against existing stored wallet
     * @param {string} [opts.firstPincode] On signup, the pincode that is being matched against
     * @param {boolean} [opts.signup=false] Whether or not the confirmation is for the initial signup
     * @throws Will throw an error if the signup pincodes don't match, or if the provided pincode doesn't decrypt the keypair.
     */
    confirmPincode: async ({ pincode, firstPincode = "", signup = false }) => {
      if (!signup) {
        try {
          const keyManager = setupKeyManager();
          let { keyId } = get_store_value(walletStore);
          await keyManager.loadKey(keyId, pincode);
        } catch (err) {
          throw error(400, { message: "invalid pincode" });
        }
      } else {
        if (pincode !== firstPincode) {
          throw error(400, { message: "pincode mismatch" });
        }
      }
    },
    /**
     * Sign and return a Stellar transaction
     * @param {Object} opts Options object
     * @param {string} opts.transactionXDR A Stellar transaction in base64-encoded XDR format
     * @param {string} opts.network Network passphrase for the network this transaction is intended for
     * @param {string} opts.pincode Pincode to be used as the encryption password for the keypair
     * @returns {Promise<Transaction>} A signed Stellar transaction ready to submit to the network
     * @throws Will throw an error if there is a problem signing the transaction.
     */
    sign: async ({ transactionXDR, network, pincode }) => {
      try {
        const keyManager = setupKeyManager();
        let signedTransaction = await keyManager.signTransaction({
          // @ts-ignore
          transaction: TransactionBuilder.fromXDR(transactionXDR, network),
          id: get_store_value(walletStore).keyId,
          password: pincode
        });
        return signedTransaction;
      } catch (err) {
        console.error("Error signing transaction", err);
        throw error(400, { message: err.toString() });
      }
    }
  };
}
const walletStore = createWalletStore();
const setupKeyManager = () => {
  const localKeyStore = new KeyManagerPlugins.LocalStorageKeyStore();
  localKeyStore.configure({
    prefix: "bpa",
    storage: localStorage
  });
  const keyManager = new KeyManager({
    keyStore: localKeyStore
  });
  keyManager.registerEncrypter(KeyManagerPlugins.ScryptEncrypter);
  return keyManager;
};
export {
  walletStore as w
};
